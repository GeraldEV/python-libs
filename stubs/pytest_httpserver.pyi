import abc
from enum import Enum
from ssl import SSLContext
from typing import Any, Callable, Iterable, Mapping, MutableMapping, Optional, Pattern, Tuple, Union

# pylint: disable=import-error, no-name-in-module, super-init-not-called, multiple-statements, too-few-public-methods, invalid-name, line-too-long
from _typeshed import Incomplete

from werkzeug.wrappers import Request, Response

URI_DEFAULT: str
METHOD_ALL: str
HEADERS_T = Union[Mapping[str, Union[str, Iterable[str]]], Iterable[Tuple[str, str]]]
HVMATCHER_T = Callable[[str, Optional[str], str], bool]

class Error(Exception): ...
class NoHandlerError(Error): ...
class HTTPServerError(Error): ...
class NoMethodFoundForMatchingHeaderValueError(Error): ...

class WaitingSettings:
    raise_assertions: Incomplete
    stop_on_nohandler: Incomplete
    timeout: Incomplete
    def __init__(self, raise_assertions: bool = ..., stop_on_nohandler: bool = ..., timeout: float = ...) -> None: ...

class Waiting:
    def __init__(self) -> None: ...
    def complete(self, result: bool): ...
    @property
    def result(self) -> bool: ...
    @property
    def elapsed_time(self) -> float: ...

class HeaderValueMatcher:
    DEFAULT_MATCHERS: MutableMapping[str, Callable[[Optional[str], str], bool]]
    matchers: Incomplete
    def __init__(self, matchers: Optional[Mapping[str, Callable[[Optional[str], str], bool]]] = ...) -> None: ...
    @staticmethod
    def authorization_header_value_matcher(actual: Optional[str], expected: str) -> bool: ...
    @staticmethod
    def default_header_value_matcher(actual: Optional[str], expected: str) -> bool: ...
    def __call__(self, header_name: str, actual: Optional[str], expected: str) -> bool: ...

class URIPattern(abc.ABC, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def match(self, uri: str) -> bool: ...

class RequestMatcher:
    uri: Incomplete
    method: Incomplete
    query_string: Incomplete
    query_matcher: Incomplete
    json: Incomplete
    headers: Incomplete
    data: Incomplete
    data_encoding: Incomplete
    header_value_matcher: Incomplete
    # def __init__(self)
    def match_data(self, request: Request) -> bool: ...
    def match_uri(self, request: Request) -> bool: ...
    def match_json(self, request: Request) -> bool: ...
    def match(self, request: Request) -> bool: ...

class RequestHandlerBase(abc.ABC, metaclass=abc.ABCMeta):
    def respond_with_json(self, response_json, status: int = ..., headers: Optional[Mapping[str, str]] = ..., content_type: str = ...): ...
    def respond_with_data(self, response_data: Union[str, bytes] = ..., status: int = ..., headers: Optional[HEADERS_T] = ..., mimetype: Optional[str] = ..., content_type: Optional[str] = ...): ...
    @abc.abstractmethod
    def respond_with_response(self, response: Response): ...

class RequestHandler(RequestHandlerBase):
    matcher: Incomplete
    request_handler: Incomplete
    def __init__(self, matcher: RequestMatcher) -> None: ...
    def respond(self, request: Request) -> Response: ...
    def respond_with_handler(self, func: Callable[[Request], Response]): ...
    def respond_with_response(self, response: Response): ...

class HandlerType(Enum):
    PERMANENT: str
    ONESHOT: str
    ORDERED: str

class HTTPServerBase(abc.ABC, metaclass=abc.ABCMeta):
    host: Incomplete
    port: Incomplete
    server: Incomplete
    server_thread: Incomplete
    assertions: Incomplete
    handler_errors: Incomplete
    log: Incomplete
    ssl_context: Incomplete
    no_handler_status_code: int
    def __init__(self, host: str, port: int, ssl_context: Optional[SSLContext] = ...) -> None: ...
    def clear(self) -> None: ...
    def clear_assertions(self) -> None: ...
    def clear_handler_errors(self) -> None: ...
    def clear_log(self) -> None: ...
    def url_for(self, suffix: str): ...
    def create_matcher(self, *args, **kwargs) -> RequestMatcher: ...
    def thread_target(self) -> None: ...
    def is_running(self) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_assertion(self, obj) -> None: ...
    def check(self) -> None: ...
    def check_assertions(self) -> None: ...
    def check_handler_errors(self) -> None: ...
    def respond_nohandler(self, request: Request, extra_message: str = ...): ...
    @abc.abstractmethod
    def dispatch(self, request: Request) -> Response: ...
    def application(self, request: Request): ...
    def __enter__(self): ...
    def __exit__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def format_host(host): ...

class HTTPServer(HTTPServerBase):
    DEFAULT_LISTEN_HOST: str
    DEFAULT_LISTEN_PORT: int
    ordered_handlers: Incomplete
    oneshot_handlers: Incomplete
    handlers: Incomplete
    permanently_failed: bool
    default_waiting_settings: Incomplete
    def __init__(self, host=..., port=..., ssl_context: Optional[SSLContext] = ..., default_waiting_settings: Optional[WaitingSettings] = ...) -> None: ...
    def clear(self) -> None: ...
    def clear_all_handlers(self) -> None: ...
    def expect_request(self, uri: Union[str, URIPattern, Pattern[str]], method: str = ..., data: Union[str, bytes, None] = ..., data_encoding: str = ..., header_value_matcher: Optional[HVMATCHER_T] = ..., handler_type: HandlerType = ..., json: Any = ...) -> RequestHandler: ...
    def format_matchers(self) -> str: ...
    def respond_nohandler(self, request: Request, extra_message: str = ...): ...
    def respond_permanent_failure(self): ...
    def dispatch(self, request: Request) -> Response: ...
    def wait(self, raise_assertions: Optional[bool] = ..., stop_on_nohandler: Optional[bool] = ..., timeout: Optional[float] = ...): ...
